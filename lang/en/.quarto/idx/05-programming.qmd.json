{"title":"Programming","markdown":{"headingText":"Programming","headingAttr":{"id":"sec-prog_r","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\nAfter learning the basics, programming in R is the next big step.\nThere are already a vast number of R packages available, surely more than enough to cover everything you could possibly want to do? Why then, would you ever need to create you own R functions? Why not just stick to the functions from a package? Well, in some cases you'll want to customise those existing functions to suit your specific needs.\nOr you may want to implement a new approach which means there won't be any pre-existing packages that work for you.\nBoth of these are not particularly common.\nFunctions are mainly used to do one thing well in a simple manner without having to type of the code necessary to do that function each time.\nWe can see functions as a short-cut to copy-pasting.\nIf you have to do a similar task 4 times or more, build a function for it, and simply call that function 4 times or call it in a loop .\n\n## Looking behind the curtain\n\nA good way to start learning to program in R is to see what others have done.\nWe can start by briefly peeking behind the curtain.\nWith many functions in R, if you want to have a quick glance at the machinery behind the scenes, we can simply write the function name but without the `()`.\n\nNote that to view the source code of base R packages (those that come with R) requires some additional steps which we won't cover here (see this [link][show-code] if you're interested), but for most other packages that you install yourself, generally entering the function name without `()` will show the source code of the function.\n\nWhat can have a look at the function to fit a linear model `lm()`\n\n```{r}\n#| label: lm-fnc\nlm\n```\n\nWhat we see above is the underlying code for this particular function.\nWe could copy and paste this into our own script and make any changes we deemed necessary, although tread carefully and test the changes you've made.\n\nDon't worry overly if most of the code contained in functions doesn't make sense immediately.\nThis will be especially true if you are new to R, in which case it seems incredibly intimidating. Honestly, it can be intimidating even after years of R experience.\nTo help with that, we'll begin by making our own functions in R in the next section.\n\n## Functions in R\n\nFunctions are the bread and butter of R, the essential sustaining elements allowing you to work with R.\nThey're made (most of the time) with the utmost care and attention but may end up being something of a Frankenstein's monster - with weirdly attached limbs.\nBut no matter how convoluted they may be they will always faithfully do the same thing.\n\nThis means that functions can also be very stupid.\n\nIf we asked you to go to the supermarket to get us some ingredients to make *Balmoral chicken*, even if you don't know what the heck that is, you'd be able to guess and bring at least *something* back.\nOr you could decide to make something else.\nOr you could ask a chef for help.\nOr you could pull out your phone and search online for what [*Balmoral chicken*][balmoral-ck] is.\nThe point is, even if we didn't give you enough information to do the task, you're intelligent enough to, at the very least, try to find a work around.\n\nIf instead, we asked a function to do the same, it would listen intently to our request, and then will simply return an error.\nIt would then repeat this every single time we asked it to do the job when the task is not clear.\nThe point here, is that code and functions cannot find workarounds to poorly provided information, which is great.\nIt's totally reliant on you, to tell it very explicitly what it needs to do step by step.\n\nRemember two things: the intelligence of code comes from the coder, not the computer and functions need exact instructions to work.\n\nTo prevent functions from being *too* stupid you must provide the information the function needs in order for it to work.\nAs with the *Balmoral chicken* example, if we'd supplied a recipe list to the function, it would have managed just fine.\nWe call this \"fulfilling an argument\".\nThe vast majority of functions require the user to fulfill at least one argument.\n\nThis can be illustrated in the pseudocode below.\nWhen we make a function we can:\n\n- specify what arguments the user must fulfill (*e.g.* `arg1` and `arg2`)\n- provide default values to arguments (*e.g.* `arg2 = TRUE`)\n- define what to do with the arguments (`expression`):\n\n```{r}\n#| label: generic_function\n#| eval: false\nmy_function <- function(arg1, arg2, ...) {\n  expression\n}\n```\n\nThe first thing to note is that we've used the function `function()` to create a new function called `my_function`.\nTo walk through the above code; we're creating a function called `my_function`.\nWithin the round brackets we specify what information (*i.e.*\narguments) the function requires to run (as many or as few as needed).\nThese arguments are then passed to the expression part of the function.\nThe expression can be any valid R command or set of R commands and is usually\ncontained between a pair of braces `{ }`.\nOnce you run the above code, you can then use your new function by typing:\n\n```{r}\n#| label: run_function\n#| eval: false\n#| out-width: 75%\nmy_function(arg1, arg2)\n```\n\nLet's work through an example to help clear things up.\n\nFirst we are going to create a data frame called `dishes`, where columns `lasagna`, `stovies`, `poutine`, and `tartiflette` are filled with 10 random values drawn from a bag (using the `rnorm()` function to draw random values from a Normal distribution with mean 0 and standard deviation of 1).\nWe also include a \"problem\", for us to solve later, by including 3 `NA` values within the `poutine` column (using `rep(NA, 3)`).\n\n```{r}\n#| label: dishes-data\n#| out-width: 75%\ndishes <- data.frame(\n  lasagna = rnorm(10),\n  stovies = rnorm(10),\n  poutine = c(rep(NA, 3), rnorm(7)),\n  tartiflette = rnorm(10)\n)\n```\n\nLet's say that you want to multiply the values in the variables `stovies` and `lasagna` and create a new object called `stovies_lasagna`.\nWe can do this \"by hand\" using:\n\n```{r}\n#| label: manual\nstovies_lasagna <- dishes$stovies * dishes$lasagna\n```\n\nIf this was all we needed to do, we can stop here.\nR works with vectors, so doing these kinds of operations in R is actually much simpler than other programming languages, where this type of code might require loops (we say that R is a vectorised language).\nSomething to keep in mind for later is that doing these kinds of operations with loops can be much slower compared to vectorisation.\n\nBut what if we want to repeat this multiplication many times? Let's say we wanted to multiply columns `lasagna` and `stovies`, `stovies` and `tartiflette`, and `poutine` and `tartiflette`.\nIn this case we could copy and paste the code, replacing the relevant information.\n\n```{r}\n#| label: simple\n#| out-width: 75%\nlasagna_stovies <- dishes$lasagna * dishes$stovies\nstovies_tartiflette <- dishes$stovies * dishes$stovies\npoutine_tartiflette <- dishes$poutine * dishes$tartiflette\n```\n\nWhile this approach works, it's easy to make mistakes.\nIn fact, here we've \"forgotten\" to change `stovies` to `tartiflette` in the second line of code when copying and pasting.\nThis is where writing a function comes in handy.\nIf we were to write this as a function, there is only one source of potential error (within the function itself) instead of many copy-pasted lines of code (which we also cut down on by using a function).\n\n::: {.callout-tip}\nAs a rule of thumb if we have to do the same thing (by copy/paste & modify) 3 times or more,\nwe just make a function for it.\n:::\n\nIn this case, we're using some fairly trivial code where it's maybe hard to make a genuine mistake.\nBut what if we increased the complexity?\n\n```{r}\n#| label: complex\n#| eval: false\ndishes$lasagna * dishes$stovies / dishes$lasagna + (dishes$lasagna * 10^(dishes$stovies))\n-dishes$stovies - (dishes$lasagna * sqrt(dishes$stovies + 10))\n```\n\nNow imagine having to copy and paste this three times, and in each case having to change the `lasagna` and `stovies` variables (especially if we had to do it more than three times).\n\nWhat we could do instead is generalize our code for `x` and `y` columns instead of naming specific dishes.\nIf we did this, we could recycle the `x * y` code.\nWhenever we wanted to multiple columns together, we assign a dishes to either `x` or `y`.\nWe'll assign the multiplication to the objects `lasagna_stovies` and `stovies_poutine` so we can come back to them later.\n\n```{r}\n#| label: manual_function\n#| eval: false\n# Assign x and y values\nx <- dishes$lasagna\ny <- dishes$stovies\n\n# Use multiplication code\nlasagna_stovies <- x * y\n\n# Assign new x and y values\nx <- dishes$stovies\ny <- dishes$poutine\n\n# Reuse multiplication code\nstovies_poutine <- x * y\n```\n\nThis is essentially what a function does.\nLet's call our new function `multiply_cols()` and define it with two arguments, `x` and `y`.\nA function in R will simply return its last value. However, it is possible to force the function to return an earlier value if wanted/needed.\nUsing the `return()` function is not strictly necessary in this example as R will automatically return the value of the last line of code in our function.\nWe include it here to make this explicit.\n\n```{r}\n#| label: first_function\nmultiply_cols <- function(x, y) {\n  return(x * y)\n}\n```\n\nNow that we've defined our function we can use it.\nLet's use the function to multiple the columns `lasagna` and `stovies` and assign the result to a new object called `lasagna_stovies_func`\n\n```{r}\n#| label: first_function2\nlasagna_stovies_func <- multiply_cols(x = dishes$lasagna, y = dishes$stovies)\nlasagna_stovies_func\n```\n\nIf we're only interested in multiplying `dishes$lasagna` and `dishes$stovies`, it would be overkill to create a function to do something once.\nHowever, the benefit of creating a function is that we now have that function added to our environment which we can use as often as we like.\nWe also have the code to create the function, meaning we can use it in completely new projects, reducing the amount of code that has to be written (and retested) from scratch each time.\n\nTo satisfy ourselves that the function has worked properly, we can compare the `lasagna_stovies` variable with our new variable `lasagna_stovies_func` using the `identical()` function.\nThe `identical()` function tests whether two objects are *exactly* identical and returns either a `TRUE` or `FALSE` value.\nUse `?identical` if you want to know more about this function.\n\n```{r}\n#| label: identical_check\nidentical(lasagna_stovies, lasagna_stovies_func)\n```\n\nAnd we confirm that the function has produced the same result as when we do the calculation manually.\nWe recommend getting into a habit of checking that the function you've created works the way you think it has.\n\nNow let's use our `multiply_cols()` function to multiply columns `stovies` and `poutine`.\nNotice now that argument `x` is given the value `dishes$stovies`and `y` the value `dishes$poutine`.\n\n```{r}\n#| label: calc_w_na\n#| eval: true\nstovies_poutine_func <- multiply_cols(x = dishes$stovies, y = dishes$poutine)\nstovies_poutine_func\n```\n\nSo far so good.\nAll we've really done is wrapped the code `x * y` into a function, where we ask the user to specify what their `x` and `y` variables are.\n\nUsing the function is a bit long since we have to retype the name of the data frame for each variable.\nFor a bit of fun we can modify the function so that, we can specify the data frame as an argument and the column names without quoting them (as in a tidyverse style).\n\n```{r}\n#| label: tidy-mult\n#| code-line-numbers: true\n\nmultiply_cols <- function(data, x, y) {\n  temp_var <- data %>%\n    select({{ x }}, {{ y }}) %>%\n    mutate(xy = prod(.)) %>%\n    pull(xy)\n}\n```\n\n\nFor this new version of the function, we added we added a `data` argument on line 1. On lines 3, we select the x and y variables provided as arguments. On line 4., we create the product of the 2 selected columns and on line 5. we extract the column we juste created.\nWe also remove the `return()` function since it was not needed\n\nOur function is now compatible with the pipe (either native `|>` or magrittr `%>%`) function.\nHowever, since the function now uses the pipe from `magrittr` :package: and `dplyr` :package: functions, we need to load the tidyverse :package: package for it to work.\n\n\n```{r}\n#| label: mult-pipe\nlibrary(tidyverse)\nlasagna_stovies_func <- multiply_cols(dishes, lasagna, stovies)\nlasagna_stovies_func <- dishes |> multiply_cols(lasagna, stovies)\n```\n\nNow let's add a little bit more complexity.\nIf you look at the output of `poutine_tartiflette` some of the calculations have produced `NA` values.\nThis is because of those `NA` values we included in `poutine` when we created the `dishes` data frame.\nDespite these `NA` values, the function appeared to have worked but it gave us no indication that there might be a problem.\nIn such cases we may prefer if it had warned us that something was wrong.\nHow can we get the function to let us know when `NA` values are produced? Here's one way.\n\n```{r}\n#| label: mult-example\n#| code-line-numbers: true\n\nmultiply_cols <- function(data, x, y) {\n  temp_var <- data %>%\n    select({{ x }}, {{ y }}) %>%\n    mutate(xy = {\n      .[1] * .[2]\n    }) %>%\n    pull(xy)\n  if (any(is.na(temp_var))) {\n    warning(\"The function has produced NAs\")\n    return(temp_var)\n  } else {\n    return(temp_var)\n  }\n}\n```\n\n```{r}\nstovies_poutine_func <- multiply_cols(dishes, stovies, poutine)\nlasagna_stovies_func <- multiply_cols(dishes, lasagna, stovies)\n```\n\nThe core of our function is still the same, but we've now got an extra six lines of code (lines 6-11).\nWe've included some conditional statements, `if` (lines 6-8) and `else` (lines 9-11), to test whether any `NA`s have been produced and if they have we display a warning message to the user.\nThe next section of this Chapter will explain how these work and how to use them.\n\n## Conditional statements\n\n`x * y` does not apply any logic.\nIt merely takes the value of `x` and multiplies it by the value of `y`.\nConditional statements are how you inject some logic into your code.\nThe most commonly used conditional statement is `if`.\nWhenever you see an `if` statement, read it as *'If X is TRUE, do a thing'*.\nIncluding an `else` statement simply extends the logic to *'If X is TRUE, do a thing, or else do something different'*.\n\nBoth the `if` and `else` statements allow you to run sections of code, depending on a condition is either `TRUE` or `FALSE`.\nThe pseudo-code below shows you the general form.\n\n```r\n  if (condition) {\n  Code executed when condition is TRUE\n  } else {\n  Code executed when condition is FALSE\n  }\n```\n\nTo delve into this a bit more, we can use an old programmer joke to set up a problem.\n\n\n> A programmer's partner says: *'Please go to the store and buy a carton of milk and if they have eggs, get six.'* \n> \n> The programmer returned with 6 cartons of milk.\n> \n> When the partner sees this, and exclaims *'Why the heck did you buy six cartons of milk?'*\n> \n> The programmer replied *'They had eggs'*\n\n\n\nAt the risk of explaining a joke, the conditional statement here is whether or not the store had eggs.\nIf coded as per the original request, the programmer should bring 6 cartons of milk if the store had eggs (condition = TRUE), or else bring 1 carton of milk if there weren't any eggs (condition = FALSE).\nIn R this is coded as:\n\n```{r}\n#| label: joke_logic\neggs <- TRUE # Whether there were eggs in the store\n\nif (eggs == TRUE) { # If there are eggs\n  n.milk <- 6 # Get 6 cartons of milk\n} else { # If there are not eggs\n  n.milk <- 1 # Get 1 carton of milk\n}\n```\n\nWe can then check `n.milk` to see how many milk cartons they returned with.\n\n```{r}\n#| label: n_milk\nn.milk\n```\n\nAnd just like the joke, our R code has missed that the condition was to determine whether or not to buy eggs, not more milk (this is actually a loose example of the [Winograd Scheme][winograd], designed to test the *intelligence* of artificial intelligence by whether it can reason what the intended referent of a sentence is).\n\nWe could code the exact same egg-milk joke conditional statement using an `ifelse()` function.\n\n```{r}\n#| label: ifelse\neggs <- TRUE\nn.milk <- ifelse(eggs == TRUE, yes = 6, no = 1)\n```\n\nThis `ifelse()` function is doing exactly the same as the more fleshed out version from earlier, but is now condensed down into a single line of code.\nIt has the added benefit of working on vectors as opposed to single values (more on this later when we introduce loops).\nThe logic is read in the same way; \"If there are eggs, assign a value of 6 to `n.milk`, if there isn't any eggs, assign the value 1 to `n.milk`\".\n\nWe can check again to make sure the logic is still returning 6 cartons of milk:\n\n```{r}\n#| label: ifelse_check\nn.milk\n```\n\nCurrently we'd have to copy and paste code if we wanted to change if eggs were in the store or not.\nWe learned above how to avoid lots of copy and pasting by creating a function.\nJust as with the simple `x * y` expression in our previous `multiply_cols()` function, the logical statements above are straightforward to code and well suited to be turned into a function.\nHow about we do just that and wrap this logical statement up in a function?\n\n```{r}\n#| label: joke_function\nmilk <- function(eggs) {\n  if (eggs == TRUE) {\n    6\n  } else {\n    1\n  }\n}\n```\n\nWe've now created a function called `milk()` where the only argument is `eggs`.\nThe user of the function specifies if eggs is either `TRUE` or `FALSE`, and the function will then use a conditional statement to determine how many cartons of milk are returned.\n\nLet's quickly try:\n\n```{r}\n#| label: joke_func_check\nmilk(eggs = TRUE)\n```\n\nAnd the joke is maintained.\nNotice in this case we have actually specified that we are fulfilling the `eggs` argument (`eggs = TRUE`).\nIn some functions, as with ours here, when a function only has a single argument we can be lazy and not name which argument we are fulfilling.\nIn reality, it's generally viewed as better practice to explicitly state which arguments you are fulfilling to avoid potential mistakes.\n\nOK, lets go back to the `multiply_cols()` function we created above and explain how we've used conditional statements to warn the user if `NA` values are produced when we multiple any two columns together.\n\n```{r}\n#| label: mult-example\n```\n\nIn this new version of the function we still use `x * y` as before but this time we've assigned the values from this calculation to a temporary vector called `temp_var` so we can use it in our conditional statements.\nNote, this `temp_var` variable is *local* to our function and will not exist outside of the function due something called [R's scoping rules][scoping].\nWe then use an `if` statement to determine whether our `temp_var` variable contains any `NA` values.\nThe way this works is that we first use the `is.na()` function to test whether each value in our `temp_var` variable is an `NA`.\nThe `is.na()` function returns `TRUE` if the value is an `NA` and `FALSE` if the value isn't an `NA`.\nWe then nest the `is.na(temp_var)` function inside the function `any()` to test whether **any** of the values returned by `is.na(temp_var)` are `TRUE`.\nIf at least one value is `TRUE` the `any()` function will return a `TRUE`.\nSo, if there are any `NA` values in our `temp_var` variable the condition for the `if()` function will be `TRUE` whereas if there are no `NA` values present then the condition will be `FALSE`.\nIf the condition is `TRUE` the `warning()` function generates a warning message for the user and then returns the `temp_var` variable.\nIf the condition is `FALSE` the code below the `else` statement is executed which just returns the `temp_var` variable.\n\nSo if we run our modified `multiple_columns()` function on the columns `dishes$stovies` and `dishes$poutine` (which contains `NA`s) we will receive an warning message.\n\n```{r  }\nstovies_poutine_func <- multiply_cols(dishes, stovies, poutine)\n```\n\nWhereas if we multiple two columns that don't contain `NA` values we don't receive a warning message\n\n```{r}\nlasagna_stovies_func <- multiply_cols(dishes, lasagna, stovies)\n```\n\n## Combining logical operators\n\nThe functions that we've created so far have been perfectly suited for what we need, though they have been fairly simplistic.\nLet's try creating a function that has a little more complexity to it.\nWe'll make a function to determine if today is going to be a good day or not based on two criteria.\nThe first criteria will depend on the day of the week (Friday or not) and the second will be whether or not your code is working (TRUE or FALSE).\nTo accomplish this, we'll be using `if` and `else` statements.\nThe complexity will come from `if` statements immediately following the relevant `else` statement.\nWe'll use such conditional statements four times to achieve all combinations of it being a Friday or not, and if your code is working or not.\n\n```{r}\n#| out-width: 75%\n#| fig-align: center\ngood.day <- function(code.working, day) {\n  if (code.working == TRUE && day == \"Friday\") {\n    \"BEST.\nDAY.\nEVER.\nStop while you are ahead and go to the pub!\"\n  } else if (code.working == FALSE && day == \"Friday\") {\n    \"Oh well, but at least it's Friday! Pub time!\"\n  } else if (code.working == TRUE && day != \"Friday\") {\n    \"So close to a good day...\nshame it's not a Friday\"\n  } else if (code.working == FALSE && day != \"Friday\") {\n    \"Hello darkness.\"\n  }\n}\n\ngood.day(code.working = TRUE, day = \"Friday\")\n\ngood.day(FALSE, \"Tuesday\")\n```\n\nNotice that we never specified what to do if the day was not a Friday? That's because, for this function, the only thing that matters is whether or not it's Friday.\n\nWe've also been using logical operators whenever we've used `if` statements.\nLogical operators are the final piece of the logical conditions jigsaw.\nBelow is a table which summarises operators.\nThe first two are logical operators and the final six are relational operators.\nYou can use any of these when you make your own functions (or loops).\n\n\n| Operator | Technical Description    | What it means               | Example                              |\n|---------:|:-----------------------:|:----------------------------|:-------------------------------------|\n| `&&`     | Logical AND             | Both conditions must be met | `if(cond1 == test && cond2 == test)` |\n| `||`     | Logical OR              | Either condition must be met| `if(cond1 == test || cond2 == test)` |\n| `<`      | Less than               | X is less than Y            | `if(X < Y)`                          |\n| `>`      | Greater than            | X is greater than Y         | `if(X > Y)`                          |\n| `<=`     | Less than or equal to   | X is less/equal to Y        | `if(X <= Y)`                         |\n| `>=`     | Greater than or equal to| X is greater/equal to Y     | `if(X >= Y)`                         |\n| `==`     | Equal to                | X is equal to Y             | `if(X == Y)`                         |\n| `!=`     | Not equal to            | X is not equal to Y         | `if(X != Y)`                         |\n\n\n## Loops\n\nR is very good at performing repetitive tasks.\nIf we want a set of operations to be repeated several times we use what's known as a loop.\nWhen you create a loop, R will execute the instructions in the loop a specified number of times or until a specified condition is met.\nThere are three main types of loop in R: the *for* loop, the *while* loop and the *repeat* loop.\n\nLoops are one of the staples of all programming languages, not just R, and can be a powerful tool (although in our opinion, used far too frequently when writing R code).\n\n### For loop\n\nThe most commonly used loop structure when you want to repeat a task a defined number of times is the `for` loop.\nThe most basic example of a `for` loop is:\n\n```{r}\n#| label: basic_for_loop\nfor (i in 1:5) {\n  print(i)\n}\n```\n\nBut what's the code actually doing? This is a dynamic bit of code were an index `i` is iteratively replaced by each value in the vector `1:5`.\nLet's break it down.\nBecause the first value in our sequence (`1:5`) is `1`, the loop starts by replacing `i` with `1` and runs everything between the `{ }`.\nLoops conventionally use `i` as the counter, short for iteration, but you are free to use whatever you like, even your pet's name, it really does not matter (except when using nested loops, in which case the counters must be called different things, like `SenorWhiskers` and `HerrFlufferkins`).\n\nSo, if we were to do the first iteration of the loop manually\n\n```{r}\n#| label: manual_loop\ni <- 1\nprint(i)\n```\n \nOnce this first iteration is complete, the for loop *loops* back to the beginning and replaces `i` with the next value in our `1:5` sequence (`2` in this case):\n\n```{r}\n#| label: manual_loop_2\ni <- 2\nprint(i)\n```\n\nThis process is then repeated until the loop reaches the final value in the sequence (`5` in this example) after which point it stops.\n\nTo reinforce how `for` loops work and introduce you to a valuable feature of loops, we'll alter our counter within the loop.\nThis can be used, for example, if we're using a loop to iterate through a vector but want to select the next row (or any other value).\nTo show this we'll simply add 1 to the value of our index every time we iterate our loop.\n\n```{r}\n#| label: altering_i\nfor (i in 1:5) {\n  print(i + 1)\n}\n```\n\nAs in the previous loop, the first value in our sequence is 1.\nThe loop begins by replacing `i` with `1`, but this time we've specified that a value of `1` must be added to `i` in the expression resulting in a value of `1 + 1`.\n\n```{r}\n#| label: altering_i_1\ni <- 1\ni + 1\n```\n\nAs before, once the iteration is complete, the loop moves onto the next value in the sequence and replaces `i` with the next value (`2` in this case) so that `i + 1` becomes `2 + 1`.\n\n```{r}\n#| label: altering_i_2\ni <- 2\ni + 1\n```\n\nAnd so on.\nWe think you get the idea! In essence this is all a `for` loop is doing and nothing more.\n\nWhilst above we have been using simple addition in the body of the loop, you can also combine loops with functions.\n\nLet's go back to our data frame `dishes`.\nPreviously in the Chapter we created a function to multiply two columns and used it to create our `lasagna_stovies`, `stovies_poutine`, and `poutine_tartiflette` objects.\nWe could have used a loop for this.\nLet's remind ourselves what our data look like and the code for the `multiple_columns()` function.\n\n```{r}\n#| label: dishes-data\n```\n\n```{r}\n#| label: mult-example\n```\n\nTo use a list to iterate over these columns we need to first create an empty list (remember @sec-lists?) which we call `temp` (short for temporary) which will be used to store the output of the `for` loop.\n\n```{r}\n#| label: loop_function\n\ntemp <- list()\nfor (i in 1:(ncol(dishes) - 1)) {\n  temp[[i]] <- multiply_cols(dishes, x = colnames(dishes)[i], y = colnames(dishes)[i + 1])\n}\n```\n\nWhen we specify our `for` loop notice how we subtracted 1 from `ncol(dishes)`.\nThe `ncol()` function returns the number of columns in our `dishes` data frame which is `4` and so our loop runs from `i = 1` to `i = 4 - 1` which is `i = 3`.\n\nSo in the first iteration of the loop `i` takes on the value `1`.\nThe `multiply_cols()` function multiplies the `dishes[, 1]` (`lasagna`) and `dishes[, 1 + 1]` (`stovies`) columns and stores it in the `temp[[1]]` which is the first element of the `temp` list.\n\nThe second iteration of the loop `i` takes on the value `2`.\nThe `multiply_cols()` function multiplies the `dishes[, 2]` (`stovies`) and `dishes[, 2 + 1]` (`poutine`) columns and stores it in the `temp[[2]]` which is the second element of the `temp` list.\n\nThe third and final iteration of the loop `i` takes on the value `3`.\nThe `multiply_cols()` function multiplies the `dishes[, 3]` (`poutine`) and `dishes[, 3 + 1]` (`tartiflette`) columns and stores it in the `temp[[3]]` which is the third element of the `temp` list.\n\nAgain, it's a good idea to test that we are getting something sensible from our loop (remember, check, check and check again!).\nTo do this we can use the `identical()` function to compare the variables we created `by hand` with each iteration of the loop manually.\n\n```{r}\n#| label: compare_3_methods\nlasagna_stovies_func <- multiply_cols(dishes, lasagna, stovies)\ni <- 1\nidentical(\n  multiply_cols(dishes, colnames(dishes)[i], colnames(dishes)[i + 1]),\n  lasagna_stovies_func\n)\n\nstovies_poutine_func <- multiply_cols(dishes, stovies, poutine)\ni <- 2\nidentical(\n  multiply_cols(dishes, colnames(dishes)[i], colnames(dishes)[i + 1]),\n  stovies_poutine_func\n)\n```\n\nIf you can follow the examples above, you'll be in a good spot to begin writing some of your own for loops.\nThat said there are other types of loops available to you.\n\n### While loop\n\nAnother type of loop that you may use (albeit less frequently) is the `while` loop.\nThe `while` loop is used when you want to keep looping until a specific logical condition is satisfied (contrast this with the `for` loop which will always iterate through an entire sequence).\n\nThe basic structure of the while loop is:\n\n```{r}\n#| eval: false\nwhile (logical_condition) {\n  expression\n}\n```\n\nA simple example of a while loop is:\n\n```{r}\ni <- 0\nwhile (i <= 4) {\n  i <- i + 1\n  print(i)\n}\n```\n\nHere the loop will only continue to pass values to the main body of the loop (the `expression` body) when `i` is less than or equal to 4 (specified using the `<=` operator in this example).\nOnce `i` is greater than 4 the loop will stop.\n\nThere is another, very rarely used type of loop; the `repeat` loop.\nThe `repeat` loop has no conditional check so can keep iterating indefinitely (meaning a break, or \"stop here\", has to be coded into it).\nIt's worthwhile being aware of it's existence, but for now we don't think you need to worry about it; the `for` and `while` loops will see you through the vast majority of your looping needs.\n\n### When to use a loop?\n\nLoops are fairly commonly used, though sometimes a little overused in our opinion.\nEquivalent tasks can be performed with functions, which are often more efficient than loops.\nThough this raises the question when should you use a loop?\n\nIn general loops are implemented inefficiently in R and should be avoided when better alternatives exist, especially when you're working with large datasets.\nHowever, loop are sometimes the only way to achieve the result we want.\n\n**Some examples of when using loops can be appropriate:**\n\n - Some simulations (e.g.\nthe Ricker model can, in part, be built using loops)\n\n - Recursive relationships (a relationship which depends on the value of the previous relationship [\"to understand recursion, you must understand recursion\"])\n\n - More complex problems (e.g., how long since the last badger was seen at site $j$, given a pine marten was seen at time $t$, at the same location $j$ as the badger, where the pine marten was detected in a specific 6 hour period, but exclude badgers seen 30 minutes before the pine marten arrival, repeated for all pine marten detections)\n\n - While loops (keep jumping until you've reached the moon)\n\n\n### If not loops, then what?\n\nIn short, use the apply family of functions; `apply()`, `lapply()`, `tapply()`, `sapply()`, `vapply()`, and `mapply()`.\nThe apply functions can often do the tasks of most \"home-brewed\" loops, sometimes faster (though that won't really be an issue for most people) but more importantly with a much lower risk of error.\nA strategy to have in the back of your mind which may be useful is; for every loop you make, try to remake it using an apply function (often `lapply` or `sapply` will work).\nIf you can, use the apply version.\nThere's nothing worse than realizing there was a small, tiny, seemingly meaningless mistake in a loop which weeks, months or years down the line has propagated into a huge mess.\nWe strongly recommend trying to use the apply functions whenever possible.\n \n\n#### lapply {-}\n\nYour go to apply function will often be `lapply()` at least in the beginning.\nThe way that `lapply()` works, and the reason it is often a good alternative to for loops, is that it will go through each element in a list and perform a task (*i.e.* run a function).\nIt has the added benefit that it will output the results as a list - something you'd have to otherwise code yourself into a loop.\n\nAn `lapply()` has the following structure:\n\n```r\nlapply(X, FUN)\n```\n\nHere `X` is the vector which we want to do *something* to.\n`FUN` stands for how much fun this is (just kidding!).\nIt's also short for \"function\".\n\nLet's start with a simple demonstration first.\nLet's use the `lapply()` function create a sequence from 1 to 5 and add 1 to each observation (just like we did when we used a for loop):\n\n```{r}\nlapply(0:4, function(a) {\n  a + 1\n})\n```\n\nNotice that we need to specify our sequence as `0:4` to get the output `1 ,2 ,3 ,4 , 5` as we are adding `1` to each element of the sequence.\nSee what happens if you use `1:5` instead.\n\nEquivalently, we could have defined the function first and then used the function in `lapply()`\n\n```{r}\nadd_fun <- function(a) {\n  a + 1\n}\nlapply(0:4, add_fun)\n```\n\nThe `sapply()` function does the same thing as  `lapply()` but instead of storing the results as a list, it stores them as a vector.\n\n```{r}\nsapply(0:4, function(a) {\n  a + 1\n})\n```\n\nAs you can see, in both cases, we get exactly the same results as when we used the for loop.\n\n```{r}\n#| label: links\n#| child: images/_links.md\n```\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","from":"markdown+emoji","number-sections":true,"output-file":"05-programming.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en-CA","fig-responsive":true,"quarto-version":"1.5.30","version":"0.6.0","year":2024,"bibliography":["biblio/book.bib","biblio/grateful-refs.bib"],"biblio-style":"apalike","csl":"biblio/ecology.csl","cit-title":"Do what you think is interesting,  \ndo something that you think is fun and worthwhile,  \nbecause otherwise you won’t do it well anyway.\n","cit-author":"Brian W. Kernighan","theme":{"light":"cosmo","dark":["cosmo","css/theme-dark.scss"]},"author-meta":"Julien Martin"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"paged","error":false,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"lualatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","from":"markdown+emoji","number-sections":true,"output-file":"05-programming.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":false,"version":"0.6.0","year":2024,"bibliography":["biblio/book.bib","biblio/grateful-refs.bib"],"biblio-style":"apalike","csl":"biblio/ecology.csl","lang":"en-CA","cit-title":"Do what you think is interesting,  \ndo something that you think is fun and worthwhile,  \nbecause otherwise you won’t do it well anyway.\n","cit-author":"Brian W. Kernighan","documentclass":"scrreprt","classoption":["chapterprefix=true","headings=big","twoside=semi"],"papersize":"letter","fontsize":"11pt","geometry":["top=2cm","bottom=2cm","left=2cm","right=2cm","footskip=1cm"],"colorlinks":true,"linestretch":1.5,"template-partials":["latex/before-title.tex","latex/before-body.tex"]},"extensions":{"book":{"selfContainedOutput":true}}},"epub":{"identifier":{"display-name":"ePub","target-format":"epub","base-format":"epub"},"execute":{"fig-width":5,"fig-height":4,"fig-format":"png","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"epub","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":false,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"default-image-extension":"png","html-math-method":"mathml","to":"epub","toc":true,"output-file":"05-programming.epub"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"version":"0.6.0","year":2024,"bibliography":["biblio/book.bib","biblio/grateful-refs.bib"],"biblio-style":"apalike","csl":"biblio/ecology.csl","lang":"en-CA","cit-title":"Do what you think is interesting,  \ndo something that you think is fun and worthwhile,  \nbecause otherwise you won’t do it well anyway.\n","cit-author":"Brian W. Kernighan","dev":"svglite","stylesheet":"css/epub.css"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf","epub"]}